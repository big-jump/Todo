{\rtf1\ansi\ansicpg1252\cocoartf1138
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Bold;
}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red249\green249\blue249;\red196\green26\blue22;
\red46\green13\blue110;\red92\green38\blue153;\red63\green110\blue116;\red100\green56\blue32;\red170\green13\blue145;
\red0\green116\blue0;\red28\green0\blue207;}
\margl1440\margr1440\vieww14500\viewh15560\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf2 \cb3 An example of an iOS Todo app that uses Core Data. This project starts with the Navigation-based project template in Xcode 4.1 and gradually builds upon it.\
This project is MIT-licensed: {\field{\*\fldinst{HYPERLINK "http://www.opensource.org/licenses/mit-license.php"}}{\fldrslt http://www.opensource.org/licenses/mit-license.php}}
\b \cf0 \cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
0. Creating the initial project and committing it to source control.\

\b0 \
We will create a new project using the Navigation-based Application project.\
\
- In the File menu choose File->New Project.\
- Choose Navigation-based Application.\
- Click Next.\
\
- Fill in the Product Name: Todo\
- Fill in the Company Identifiier: com.example\
- Uncheck Include Unit Tests\
- Click Next.\
\
- Choose project location (like on the Desktop, for example)\
- Click Create.\
\

\b 1. Add .gitignore\

\b0 \

\b 2. Create a TodoItem Entity to store the todo items\

\b0 \
We will create a TodoItem Entity to represent the todo items. We'll do this by modifying the Event Entity that was generated by the project template.\
\
- In the Project navigator click on Todo.xcdatamodeld.\
- In the Entities list, click on Event. \
- Click on the text so that it becomes an editable text field.\
- Rename it to TodoItem.\
- In the Attributes list for the TodoItem Entity, rename timeStamp to dueDate.\
- Keep the type as Date.\
- Click the + button to add a new attribute and change the attribute name to name.\
- Change the type to String.\
- Add a new attribute and give it the name done.\
- Change the type to Boolean\
\
- In the File menu choose File->New->New File.\
- In the iOS section, choose Core Data.\
- Pick NSManagedObject subclass.\
- Click Create\
\
- In RootViewController.m inside the method named fetchedResultsController change the Entity name from 
\f1\fs22 \cf4 \CocoaLigature0 @"Event"
\f0\fs24 \cf0 \CocoaLigature1  to 
\f1\fs22 \cf4 \CocoaLigature0 @"TodoItem"
\f0\fs24 \cf0 \CocoaLigature1 (line 204)\
- Change the sort descriptor key from 
\f1\fs22 \cf4 \CocoaLigature0 @"timeStamp"
\f0\fs24 \cf0 \CocoaLigature1  to 
\f1\fs22 \cf4 \CocoaLigature0 @"dueDate" 
\f0\fs24 \cf0 \CocoaLigature1 (line 211)\
- In the configureCell:atIndexPath: method, change 
\f1\fs22 \cf4 \CocoaLigature0 @"timeStamp" 
\f0\fs24 \cf0 \CocoaLigature1 to 
\f1\fs22 \cf4 \CocoaLigature0 @"dueDate"
\f0\fs24 \cf0 \CocoaLigature1  (161)\
- In insertNewObject change 
\f1\fs22 \cf4 \CocoaLigature0 @"timeStamp" 
\f0\fs24 \cf0 \CocoaLigature1 to 
\f1\fs22 \cf4 \CocoaLigature0 @"dueDate"
\f0\fs24 \cf0 \CocoaLigature1  (line 173)\
\
You should now be able to run the app in the simulator and insert new TodoItem objects. If the app crashes on launch, delete the app from the iOS simulator or device and rebuild.\
\

\b 3. Start using TodoItem class instead of plain NSManagedObject\

\b0 \
Import 
\f1\fs22 \cf4 \CocoaLigature0 "TodoItem.h"
\f0\fs24 \cf0 \CocoaLigature1  so that we can start using a specific NSManagedObject subclass instead of using just plain NSManagedObject with Key-Value Coding.\
\

\b 4. Change the style of the table view cell to something more appropriate\

\b0 \
- In tableView:cellForRowAtIndexPath: change 
\f1\fs22 \cf5 \CocoaLigature0 UITableViewCellStyleDefault
\f0\fs24 \cf0 \CocoaLigature1  to 
\f1\fs22 \cf5 \CocoaLigature0 UITableViewCellStyleValue1
\f0\fs24 \cf0 \CocoaLigature1  (line 79)\
- In 
\f1\fs22 \CocoaLigature0 configureCell:atIndexPath:
\f0\fs24 \CocoaLigature1  change 
\f1\fs22 \CocoaLigature0 cell.\cf6 textLabel\cf0 .\cf6 text
\f0\fs24 \cf0 \CocoaLigature1  to 
\f1\fs22 \CocoaLigature0 cell.\cf6 detailTextLabel\cf0 .\cf6 text
\f0\fs24 \cf0 \CocoaLigature1  (line 162)\
- Under that line add: 
\f1\fs22 \CocoaLigature0 cell.\cf6 textLabel\cf0 .\cf6 text\cf0  = todoItem.\cf7 name\cf0 ;
\f0\fs24 \CocoaLigature1 \
- If the todo item is done, set the cell's accessoryType to 
\f1\fs22 \cf5 \CocoaLigature0 UITableViewCellAccessoryCheckmark
\f0\fs24 \cf0 \CocoaLigature1 \
- If it's not done, set it to 
\f1\fs22 \cf5 \CocoaLigature0 UITableViewCellAccessoryNone
\f0\fs24 \cf0 \CocoaLigature1 \
\
There are some immediate problems with the app: There's no default name for the todo items and the due date description is too long. Also, we can't edit any of the data. We'll fix that soon.\
\

\b 5. Add a default name for each new TodoItem being added\

\b0 \
We need to add a default name for each todo item begin added.\
\
- In the 
\f1\fs22 \CocoaLigature0 insertNewObject
\f0\fs24 \CocoaLigature1  method of RootViewController.m, add the line \

\f1\fs22 \CocoaLigature0 newTodoItem.\cf7 name\cf0  = \cf4 @"New todo"\cf0 ; (182)\
after the line\
newTodoItem.\cf7 dueDate\cf0  = [\cf6 NSDate\cf0  \cf5 date\cf0 ]; (181)\
\

\f2\b 6. Add a date formatter (NSDateFormatter) and use it to display a more appropriate date description\

\f1\b0 \
We will create an instance property for an NSDateFormatter that will be created on-demand. This date formatter will be used to format the due date displayed in the todo list so that it's shorter and more appropriate.\
\
Also, \cf5 UITableViewCellStyleValue1 \cf0 still looks too crowded, so let's try another cell style, \cf5 UITableViewCellStyleSubtitle.\
\

\f2\b \cf0 7. Editing a todo item's details: Creating the detail view controller\

\f1\b0 \

\f0\fs24 Tapping on a table view cell should take us to a new screen that shows the details for that selected todo item.\
\
- In the File menu select New->New File.\
- Under the iOS section click on Cocoa Touch\
- Select UIViewController subclass and click Next.\
- Make it a subclass of UITableViewController. You can select this from the drop-down menu\
- Click Next\
- Name it DetailViewController\
- Click Next\
\
We need to make sure that this view controller gets pushed on to the navigation stack so that the detail view will be displayed.\
\
- At the top of RootViewController.m at the end of the other import statements add
\f1\fs22  \cf8 #import \cf4 "DetailViewController.h"\

\f0\fs24 \cf0 - Remove the multi-line comment markers in 
\f1\fs22 tableView:didSelectRowAtIndexPath:\

\f0\fs24 - On the first line of the method, fill in the placeholders with DetailViewController for the class name\
- You can double-click the placeholders to automatically use their placeholder content. Since the class has the same name, this will work as intended.\
- Change the nib name parameter to 
\f1\fs22 \cf4 @"DetailViewController"\

\f0\fs24 \
\cf0 - The Root view needs a title so that the Detail view's Back button will have a title.\
- In viewDidLoad, add 
\f1\fs22 \cf9 self\cf0 .\cf6 title\cf0  = \cf4 @"Todo List"\cf0 ; at the end of the method\

\f0\fs24 \
You should now be able to show a blank detail view when a todo item is selected.\

\f1\fs22 \
\

\f2\b 8. Display todo item details in DetailViewController\

\f0\b0\fs24 \
We're going to change the table view style to the grouped style. Then we're going to add a property to the DetailViewController class so that we can reference the selected TodoItem. Finally we'll use that TodoItem to show the details in the table view owned by the DetailViewController.\
\
- In the Project navigation, select DetailViewController.xib\
- Select the UITableView in the xib\
- In the Utility editor (Cmd+Alt+4), change the Table View Style to Grouped\
\
- In DetailViewController.h, add a forward class declaration right before the 
\f1\fs22 \cf9 @interface\cf0  declaration: \cf9 @class\cf0  \cf7 TodoItem\cf0 ;\

\f0\fs24 - Inside the 
\f1\fs22 \cf9 @interface \cf0 declaration add a property to reference the TodoItem instance: \cf9 @property\cf0  (\cf9 nonatomic\cf0 , \cf9 retain\cf0 ) \cf7 TodoItem\cf0  *detailItem;\

\f0\fs24 \
- In DetailViewController.m, import the header for the TodoItem class: 
\f1\fs22 \
\cf8 #import \cf4 "TodoItem.h"\cf0 \
- Inside the \cf9 @implementation \cf0 section generate the property setter/getter and instance variable (ivar) by adding the synthesize statement for the property: \cf9 @synthesize\cf0  detailItem = \cf7 __detailItem\cf0 ;\

\f0\fs24 - Add a dealloc method to clean up the property
\f1\fs22 \
\pard\tx560\pardeftab560\pardirnatural
\cf0 - (\cf9 void\cf0 )dealloc\
\{\
    [\cf7 __detailItem\cf0  \cf5 release\cf0 ];\
    [\cf9 super\cf0  \cf5 dealloc\cf0 ];\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 \
We'll also need a date formatter to correctly display the due date.\
- In DetailViewController.h, add a property for an NSDateFormatter:
\f1\fs22 \
\pard\tx560\pardeftab560\pardirnatural
\cf9 @property\cf0  (\cf9 nonatomic\cf0 , \cf9 retain\cf0 ) \cf6 NSDateFormatter\cf0  *dueDateFormatter;\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 - In DetailViewController.m synthesize the date formatter:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf9 @synthesize\cf0  dueDateFormatter = \cf7 __dueDateFormatter\cf0 ;\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 - Release the instance variable in the dealloc method. The dealloc method should now look like this:\
\pard\tx560\pardeftab560\pardirnatural
\cf0 - (\cf9 void\cf0 )dealloc\
\{\
    [\cf7 __detailItem\cf0  \cf5 release\cf0 ];\
    [\cf7 __dueDateFormatter\cf0  \cf5 release\cf0 ];\
    [\cf9 super\cf0  \cf5 dealloc\cf0 ];\
\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \

\f0\fs24 Create an accessor method for the date formatter that will create it on-demand. This will be similar to the date formatter method from the RootViewController class, except that it uses the medium style for dates:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0 - (\cf6 NSDateFormatter\cf0 *)dueDateFormatter\
\{\
    \cf9 if\cf0  (\cf7 __dueDateFormatter\cf0  != \cf9 nil\cf0 ) \{\
        \cf9 return\cf0  \cf7 __dueDateFormatter\cf0 ;\
    \}\
    \
    \cf7 __dueDateFormatter\cf0  = [[\cf6 NSDateFormatter\cf0  \cf5 alloc\cf0 ] \cf5 init\cf0 ];\
    \cf7 __dueDateFormatter\cf0 .\cf6 dateStyle\cf0  = \cf5 NSDateFormatterMediumStyle\cf0 ;\
    \cf7 __dueDateFormatter\cf0 .\cf6 timeStyle\cf0  = \cf5 NSDateFormatterShortStyle\cf0 ;\
    \cf9 return\cf0  \cf7 __dueDateFormatter\cf0 ;\
\}
\f0\fs24 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f1\fs22 \cf0 \

\f0\fs24 - In DetailViewController.m in numberOfSectionsInTableView: remove the #warning and change the method so that it returns 1.\
- In DetailViewController.m in tableView:numberOfRowsInSection: remove the #warning and change the method so that it returns 2.
\f1\fs22 \

\f0\fs24 \CocoaLigature1 - In tableView:cellForRowAtIndexPath: change 
\f1\fs22 \cf5 \CocoaLigature0 UITableViewCellStyleDefault
\f0\fs24 \cf0 \CocoaLigature1  to 
\f1\fs22 \cf5 \CocoaLigature0 UITableViewCellStyleValue2
\f0\fs24 \cf0 \CocoaLigature1 \
\
\CocoaLigature0 - We're going to co\CocoaLigature1 nfigure the table view cells directly in 
\f1\fs22 \CocoaLigature0 tableView:cellForRowAtIndexPath:\

\f0\fs24 - In DetailViewController.m right after the comment 
\f1\fs22 \cf10 // Configure the cell... 
\f0\fs24 \cf0 \CocoaLigature1 add:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0 \CocoaLigature0     \cf6 CGRect\cf0  textFieldRect = \cf5 CGRectMake\cf0 (\cf11 0\cf0 , \cf11 0\cf0 , \cf11 200\cf0 , \cf11 21\cf0 );\
    \
    \cf9 if\cf0  (indexPath.\cf6 row\cf0  == \cf11 0\cf0 ) \{\
        cell.\cf6 textLabel\cf0 .\cf6 text\cf0  = \cf4 @"name"\cf0 ;\
        \cf6 UITextField\cf0  *nameField = [[\cf6 UITextField\cf0  \cf5 alloc\cf0 ] \cf5 initWithFrame\cf0 :textFieldRect];\
        cell.\cf6 accessoryView\cf0  = nameField;\
        nameField.\cf6 text\cf0  = \cf9 self\cf0 .\cf7 detailItem\cf0 .\cf7 name\cf0 ;\
        [nameField \cf5 release\cf0 ];\
    \}\
    \cf9 else\cf0  \{\
        cell.\cf6 textLabel\cf0 .\cf6 text\cf0  = \cf4 @"due date"\cf0 ;\
        \cf6 UITextField\cf0  *dateField = [[\cf6 UITextField\cf0  \cf5 alloc\cf0 ] \cf5 initWithFrame\cf0 :textFieldRect];\
        cell.\cf6 accessoryView\cf0  = dateField;\
        dateField.\cf6 text\cf0  = [\cf9 self\cf0 .\cf7 dueDateFormatter\cf0  \cf5 stringFromDate\cf0 :\cf9 self\cf0 .\cf7 detailItem\cf0 .\cf7 dueDate\cf0 ];\
        [dateField \cf5 release\cf0 ];\
    \}\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 - This adds a title label for each cell and adds a text field that will display the name and due date.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
- Back in RootViewController.m in the tableView:didSelectRowAtIndexPath: assign the detail item right before you push it on to the navigation controller:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0     detailViewController.\cf7 detailItem\cf0  = [\cf9 self\cf0 .\cf7 fetchedResultsController\cf0  \cf5 objectAtIndexPath\cf0 :indexPath];\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 \
You should now be able to see the details in the detail screen when you select a todo item from the main list. We'll work on editing those details next.
\f1\fs22 \
\
\pard\tx560\pardeftab560\pardirnatural

\f2\b \cf0 9. Adding a date picker\
\pard\tx560\pardeftab560\pardirnatural

\f1\b0 \cf0 \
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 We're going to add a property for a UIDatePicker that's marked as an IBOutlet so we can connect its representation that we'll add in DetailViewController.xib. We'll also add and connect an action method that will get called when the date picker changes.\
\
- In t
\f1\fs22 he DetailViewController.h file Add a property for a UIDatePicker marked as an IBOutlet so that later on we can connect it in the nib:\
\pard\tx560\pardeftab560\pardirnatural
\cf9 @property\cf0  (\cf9 nonatomic\cf0 , \cf9 retain\cf0 ) \cf9 IBOutlet\cf0  \cf6 UIDatePicker\cf0  *dueDatePicker;\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 - While we're in the header, lets also add the action method that will get called when the picker changes:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0 - (\cf9 IBAction\cf0 )dateDidChange:(\cf9 id\cf0 )sender;
\f0\fs24 \
\
- In the DetailViewController.m file, synthesize the property\

\f1\fs22 \cf9 @synthesize\cf0  dueDatePicker = \cf7 __duedatePicker\cf0 ;\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 \
- And release it in the dealloc method\
\
- Add the implementation for the dateDidChange: method. It changes the dueDate property of the detail item and updates the corresponding text field.\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0 - (\cf9 IBAction\cf0 )dateDidChange:(\cf9 id\cf0 )sender\
\{\
    \cf6 UIDatePicker\cf0  *datePicker = (\cf6 UIDatePicker\cf0 *)sender;\
    \cf9 self\cf0 .\cf7 detailItem\cf0 .\cf7 dueDate\cf0  = datePicker.\cf6 date\cf0 ;\
    \
    \cf6 NSIndexPath\cf0  *dueDateIndexPath = [\cf6 NSIndexPath\cf0  \cf5 indexPathForRow\cf0 :\cf11 1\cf0  \cf5 inSection\cf0 :\cf11 0\cf0 ];\
    \cf6 UITableViewCell\cf0  *cell = [\cf9 self\cf0 .\cf6 tableView\cf0  \cf5 cellForRowAtIndexPath\cf0 :dueDateIndexPath];\
    \cf6 UITextField\cf0  *dateTextField = (\cf6 UITextField\cf0 *)cell.\cf6 accessoryView\cf0 ;\
    dateTextField.\cf6 text\cf0  = [\cf9 self\cf0 .\cf7 dueDateFormatter\cf0  \cf5 stringFromDate\cf0 :\cf9 self\cf0 .\cf7 detailItem\cf0 .\cf7 dueDate\cf0 ];\
\}\
\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 - In the nib file DetailViewController.xib, open the Object Library in the bottom part of the Utility editor (Control + Alt + Command + 3).\
- Drag out a Date Picker and place it in the nib as a sibling to the table view. You can use the text field to filter your search\
- Hold down Control and drag from File's Owner to the date picker to connect the date picker to its property.\
- Now going back the other way, hold down Control and drag from the date picker to File's Owner and connect the dateDidChange: action method.\
\
- Back in the DetailViewController.m file, we need to set the date picker as the input view of the due date text field so that the picker comes up when we tap in the the due date field.\
- In the tableView:cellForRowAtIndexPath: we assign the inputView property of dateField to the date picker:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0         dateField.\cf6 inputView\cf0  = \cf9 self\cf0 .\cf7 dueDatePicker\cf0 ;\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 \
\
We're now able to use a date picker to change the due date of a todo item. But there's still a few issues that we need to fix.\
\
\pard\tx560\pardeftab560\pardirnatural

\b \cf0 10. Usability improvements in DetailViewController\
\pard\tx560\pardeftab560\pardirnatural

\b0 \cf0 \
There are a few things we need to fix in the DetailViewController implementation:\
- Users should be able to tap anywhere in the table view cell in order to edit it; they shouldn't be required to tap directly into the text field.\
- The table view highlight should de-select after each press as well. \
- We should add a Clear button to the name text field so that the user won't have to hit the delete key several times to clear out the default name. \
- The todo item name needs to be saved. \
- Lastly, the detail view needs a title in the navigation bar.\
\
- Table view cell need to de-select after being selected\
- At the top of the tableView:didSelectRowAtIndexPath: add the line:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0     [tableView \cf5 deselectRowAtIndexPath\cf0 :indexPath \cf5 animated\cf0 :\cf9 YES\cf0 ];\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 - When a table view cell is selected we need to tell the correct text field to start receiving input by becoming First Responder.
\f1\fs22 \

\f0\fs24 - Go ahead and delete the remaining comments in the method and replace it with:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0     \cf6 UITableViewCell\cf0  *cell = [tableView \cf5 cellForRowAtIndexPath\cf0 :indexPath];\
    \cf6 UITextField\cf0  *textField = (\cf6 UITextField\cf0 *)cell.\cf6 accessoryView\cf0 ;\
    [textField \cf5 becomeFirstResponder\cf0 ];\
\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 - We need to add a Clear button to the name text field that is displayed while editing.\
- In the tableView:cellForRowAtIndexPath: method set the clearButtonMode property of the nameField:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0         nameField.\cf6 clearButtonMode\cf0  = \cf5 UITextFieldViewModeWhileEditing\cf0 ;\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 - The method viewWillDisappear: gets called right before the view managed by DetailViewController disappears from sight. So this is a good place for us to save the text from the name field.\
- In viewWillDisappear: we'll get a reference to the name text field and assign its text to the name property of the todo item:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0     \cf6 NSIndexPath\cf0  *nameIndexPath = [\cf6 NSIndexPath\cf0  \cf5 indexPathForRow\cf0 :\cf11 0\cf0  \cf5 inSection\cf0 :\cf11 0\cf0 ];\
    \cf6 UITableViewCell\cf0  *cell = [\cf9 self\cf0 .\cf6 tableView\cf0  \cf5 cellForRowAtIndexPath\cf0 :nameIndexPath];\
    \cf6 UITextField\cf0  *nameTextField = (\cf6 UITextField\cf0 *)cell.\cf6 accessoryView\cf0 ;\
    \cf9 self\cf0 .\cf7 detailItem\cf0 .\cf7 name\cf0  = nameTextField.\cf6 text\cf0 ;
\f0\fs24 \
\
- In the viewDidLoad method we'll assign a title that will get displayed in the navigation bar:\

\f1\fs22     \cf9 self\cf0 .\cf6 title\cf0  = \cf4 @"Details"\cf0 ;\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 \
The detail view should now be easier to use, but we still need a way to mark an item as done. We'll do this next.\
\
11. Mark todo items as done\
\
We need a way to check off completed todo items. We'll add a swipe gesture recognizer to toggle the done property of a todo item.\
\
- In tableView:cellForRowAtIndexPath: create a UISwipeGestureRecognizer and assign it to each table view cell after the initial call to alloc and initWithStyle:reuseIdentifier:\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0         \cf6 UISwipeGestureRecognizer\cf0  *swipeGestureRecognizer = [[\cf6 UISwipeGestureRecognizer\cf0  \cf5 alloc\cf0 ] \cf5 initWithTarget\cf0 :\cf9 self\cf0  \cf5 action\cf0 :\cf9 @selector\cf0 (toggleDone:)];\
        [cell \cf5 addGestureRecognizer\cf0 :swipeGestureRecognizer];\
        [swipeGestureRecognizer \cf5 release\cf0 ];
\f0\fs24 \
- The target in initWithTarget:action: is 
\f1\fs22 \cf9 self
\f0\fs24 \cf0  (this RootViewController) and the action is the method toggleDone:\
- We define toggleDone: by declaring it in RootViewController.h\

\f1\fs22 - (\cf9 void\cf0 )toggleDone:(\cf6 UISwipeGestureRecognizer\cf0 *)sender;\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 - Then we create the implementation in RootViewController.m\
\pard\tx560\pardeftab560\pardirnatural

\f1\fs22 \cf0 - (\cf9 void\cf0 )toggleDone:(\cf6 UISwipeGestureRecognizer\cf0 *)sender;\
\{\
    \cf6 UITableViewCell\cf0  *cell = (\cf6 UITableViewCell\cf0 *)sender.\cf6 view\cf0 ;\
    \cf6 NSIndexPath\cf0  *indexPath = [\cf9 self\cf0 .\cf6 tableView\cf0  \cf5 indexPathForCell\cf0 :cell];\
    \cf7 TodoItem\cf0  *todo = [\cf9 self\cf0 .\cf7 fetchedResultsController\cf0  \cf5 objectAtIndexPath\cf0 :indexPath];\
    \cf10 // The done property is an NSNumber\cf0 \
    \cf9 if\cf0  ([todo.\cf7 done\cf0  \cf5 boolValue\cf0 ] == \cf9 NO\cf0 ) \{\
        todo.\cf7 done\cf0  = [\cf6 NSNumber\cf0  \cf5 numberWithBool\cf0 :\cf9 YES\cf0 ];\
    \}\
    \cf9 else\cf0  \{\
        todo.\cf7 done\cf0  = [\cf6 NSNumber\cf0  \cf5 numberWithBool\cf0 :\cf9 NO\cf0 ];\
    \}\
\}\
\
\pard\tx560\pardeftab560\pardirnatural

\f0\fs24 \cf0 We should now be able to mark todo items as done or not done.\
\
\pard\tx560\pardeftab560\pardirnatural

\b \cf0 12. Final touches: App icon and Default image\
\pard\tx560\pardeftab560\pardirnatural

\b0 \cf0 \
- We're going to add an app icon and a default loading image.\
- In the Project navigator, select the Todo project icon\
- In the second column, select the Todo target in Targets\
- Select the Summary tab\
- Drag any .png file named Icon@2x.png (114 x 114 pixels) into the App Icons area for Retina Display icons.\
- Drag any .png file named Icon.png (57 pixels x 57 pixels) into the App Icons area for regular icons.\
\
We need to set a some loading screens. These can be any .png files sized 640x980 pixels for Retina Display and 320x480 pixels for a regular display.\
\
- You can create these default screen images in the Organizer (Windows->Organizer or Shift+Command+2). \
- In the Organizer under Screenshots, you can use the Save as Launch Image to create assign the default loading image.\
- Or you can drag any correctly sized .png images to the Launch Images areas in the Summary tab.\
\
You should now have an App icon and a Launch image.}